---

layout: post
title: 总纲——如何学习架构
category: 架构
tags: Architecture
keywords: project

---

## 简介

* TOC
{:toc}

借助[如何学习分布式系统](http://qiankunli.github.io/2018/04/16/learn_distributed_system.html) 得来的经验，当一个知识足够复杂，如何学习它本身就很值得玩味

到目前为止，笔者关于架构的几篇文章或笔记

1. [《软件架构设计》笔记](http://qiankunli.github.io/2019/04/16/architecture_design_note.html)
2. [反应式架构摸索](http://qiankunli.github.io/2019/01/21/reactive_architecture.html)
3. [业务系统设计的一些体会](http://qiankunli.github.io/2018/09/28/business_system_design.html)
4. [《左耳听风》笔记](http://qiankunli.github.io/2018/09/08/zuoertingfeng_note.html)
5. [《从0开始学架构》笔记](http://qiankunli.github.io/2018/05/06/architecture_from_0_note.html)

按照许式伟的说法，架构相关的图书大概有几类

1. 架构思维类。 通常从一些著名的架构理论讲起，比如开闭原则、单一职责原则等等。其弊端在于过度理论化，而计算机科学归根到底属于工程技术类，应该实践第一。
2. 设计模式类。 这类一般上来就进入架构的局部细节，每个模式的来龙去脉并不容易理解。就算理解了某个具体的模式，也很难真正做到活学活用。
3. 分布式系统架构设计类。 通常从服务端的通用问题如一致性、高可用、高并发挑战等话题讲起，阐述大型业务系统面临的挑战。这些知识虽然非常有价值，但无法延伸至通用业务架构，对大部分企业的架构实践不具备真正的指导意义。
4. 重构类。 主要讲如何如何改进代码，其实是最实用的一类。但在我看来，一个模块最初的地基是最重要的，基本决定了这座大厦能够撑多久，而重构更多侧重于大厦建成之后，在服务于人的前提下怎么去修修补补，延长生命。

也有人主张：最好的软件设计是简单易懂的设计，[软件架构被高估，清晰简单的设计被低估](https://mp.weixin.qq.com/s/1ffiH9ODSzcr79IknW6QSw)

1. 拉过一名同事，在白板上写下你的设计方法。写出你在做什么，为什么要这么做，征求他们的意见
2. 设计两种方案，并进行对比。大多数人在设计架构时都只采用一种方法，就是突然出现在他们脑海中的方法。提出第二个同样可行的设计。对比两者，解释为什么一个比另一个更好。简要列出第二种设计作为备选方案，并说明为什么决定不用它。

## 架构总纲——纲举目张

语言、数据结构、算法、中间件使用等属于硬的内容，比如容易表述，也容易衡量。而架构设计，系统的“三高”则属于“隐性问题”

1. 因为一个系统设计问题导致研发人力的投入和时间成本的增加
2. 业务确实很复杂，做新功能有沉重的历史包袱，最终技术拖累业务

架构是针对所有重要问题做出的重要决策。很显然，不同公司不同阶段碰到的问题不同，架构所做的事情自然也不一样。

架构的道

1. 对于技术问题，主要指高并发、高可用和一致性方面
2. 对于业务问题，主要指业务的需求分析和业务建模

|道|术|
|---|---|
|内功心法|外功招式|
|知（理论）|行（实践）|
|问题|答案|

![](/public/upload/architecture/architecture.png)

当你碰到一篇文章、技术、知识点，有自己的方法论，能够place it in context，分析其在架构知识的哪一层

![](/public/upload/architecture/tech_value.png)

## 当你不具体负责某一个业务或系统，如何看待架构，如何让架构体现价值

更抽象一下就是：业务对技术有什么要求？支持更多业务，响应更快，能服务越来越多人（更强），低成本。资源伸缩、资源成本（这两个阿里已接近解决）、研发效率。

WWW的发明人蒂姆.伯纳斯.李谈到设计原理时说过：简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。

[阿里毕玄：系统架构师如何做好系统设计？](https://mp.weixin.qq.com/s/LrpvaAQSn_TITMwH7XhG3A)

1. 有了清晰的可衡量的系统建设的目标，最容易遗漏的一点，是可以做一个用来跟踪系统建设效果的系统
2. 从可衡量的目标映射到技术层面要去解决的核心问题，是很需要技术功底的。如果要达成系统设计的可衡量的目标，到底面临了一些什么核心问题，只有明白了面临什么核心问题，才能更加明确的进行系统设计来解决这些问题。
3. 访问量大的系统最重要的是对整个系统的处理过程要非常的清楚，因为在访问量大的情况下，一些小的问题有可能会放大成很大的问题，进而到故障，所以访问量大的系统对技术的可控性要求是极高的

![](/public/upload/architecture/ali_architecture_in_distribute.png)

单点带来的性能、容量瓶颈 以及研发协作效率瓶颈 逼着进行了分布式改造。

![](/public/upload/architecture/ali_architecture_multi_unit.png)

![](public/upload/architecture/ali_architecture_cloud.png)

云时代的软件架构走向何方？

1. 第一点是弹性，我可以有高峰就用、没有高峰就退。
2. 第二点，业务研发团队会越来越不关注下面是什么，越来越脱离下面这一层。一个新人加入进来，可以不管那么多context就可以去实现业务需求。

![](/public/upload/architecture/ali_architecture_future.png)

## 具体的架构分类

![](/public/upload/architecture/architecture_category.png)

## 系统架构

* 微服务 
* 一个问题在一个进程的多线程间存在，多半也在一台机器的多进程，多台机器的多进程间存在，而解决问题的思路多半是一样的，这也是学习基础的必要性所在。比如[一分钟实现分布式锁](http://www.10tiao.com/html/249/201612/2651959749/1.html)

[谈谈互联网后端基础设施](https://yq.aliyun.com/articles/66115)要点：

1. Api网关 
2. 业务应用和后端基础框架 
3. 缓存、数据库、搜索引擎、消息队列、文件存储 
4. 统一认证中心 单点登录系统 
5. 统一配置中心 
6. 服务治理框架 
7. 统一日志服务 
8. 数据基础设施 
9. 故障监控

这里的后端基础设施主要指的是应用在线上稳定运行需要依赖的关键组件/服务等。开发或者搭建好以上的后端基础设施，一般情况下是能够支撑很长一段时间内的业务的。此外，对于一个完整的架构来说，还有很多应用感知不到的系统基础服务，如负载均衡、自动化部署、系统安全等

### 并发读写

[那些年追过的并发](http://qiankunli.github.io/2019/08/05/concurrency.html)

《软件架构设计》要让各式各样的业务功能与逻辑最终在计算机系统里实现，只能通过两种操作：读和写。PS：[并发读写是线程安全的核心问题](http://qiankunli.github.io/2014/10/09/Threads.html)

![](/public/upload/architecture/high_concurrency.png)

### 可用性与稳定性

![](/public/upload/architecture/high_availability.png)

## 业务架构

《软件架构设计》为什么要区分“业务架构”和“技术架构”？要时刻意识到我们面对的是业务问题还是技术问题。

1. 能够通过架构设计降低业务代码修改（对应功能的增删改）的难度吗？
2. 如果能，如何通过架构设计降低业务代码修改的难度？

### 方法论

![](/public/upload/architecture/businese_thought.png)

很多时候会遇到这样的情况：一个函数写了几百行代码，里面的if-else写了很多，计算各种业务规则。另一个人接手后，分析了好几天，才把业务逻辑彻底理清楚。**这个问题表面上看是代码写的不规范、要重构。从根本上讲，就是重要逻辑隐藏在代码里面，没有”显性“的表达出来**。这只是一个函数，推广到类、模块、系统，是同样的道理。

所以，建模的本质就是：把重要的东西进行显性化，进而把这些显性化的构造块互相串联起来，组成一个体系。**让它在”设计图纸“上可见，而不是分析完代码才能看出来**。重要的东西找到了，如何显性化呢？其实就是”命名“

### 典型/非典型架构

1. 典型架构：browser—server，app-server
	
	* [关于互联网“一致性”架构设计的一切](http://www.10tiao.com/html/249/201709/2651960408/1.html)
	* [互联网分层架构的本质](http://www.10tiao.com/html/249/201710/2651960455/1.html) 文章要点：互联网分层架构的本质，是数据的移动；互联网分层架构中，数据的传输格式（协议）与数据在各层次的形态很重要；互联网分层架构演进的核心原则与方法：封装与复用
	
2. 非典型架构：[秒杀，推送，广告，推荐，计数-互联网非典型业务系统架构设计](http://www.10tiao.com/html/249/201709/2651960426/1.html)

### 通用设计

1. 满足业务需求
2. 解耦 [为什么说解耦的战术，决定了架构的高度？](http://www.sohu.com/a/204009990_411876)

	* ip耦合：使用内网域名代替内网ip
	* 公共库耦合：业务个性强的垂直拆分，公共特性强的下沉服务化
	* 数据库耦合：垂直切分与服务化
	* 服务化耦合：剥离业务代码上浮
	* 消息通知耦合：MQ
	* 下游扩容耦合：配置中心

[互联网架构：屡试不爽的架构三马车](https://mp.weixin.qq.com/s/VBGeI308sbTn8qNY-wASjQ)：微服务、消息队列和定时任务

![](/public/upload/architecture/business_architecture.png)


## 串一串编程范式

[架构整洁之道, 看这一篇就够了！](https://mp.weixin.qq.com/s/Kd1T40KZWvdThKC3IN6n-Q)

架构是软件系统的一部分，所以要明白架构的价值，首先要明确软件系统的价值。软件系统的价值有两方面，行为价值和架构价值。

1. 行为价值是软件的核心价值，包括需求的实现，以及可用性保障（功能性 bug 、性能、稳定性）。这几乎占据了我们90%的工作内容，支撑业务先赢是我们工程师的首要责任。**如果业务是明确的、稳定的，架构的价值就可以忽略不计，但业务通常是不明确的、飞速发展的，这时架构就无比重要，因为架构的价值就是让我们的软件（Software）更软（Soft）**。
2. 架构价值

    1. 当需求变更时，所需的软件变更必须简单方便。
    2. 变更实施的难度应该和变更的范畴（scope）成等比，而与变更的具体形状（shape）无关。

实现行为价值的需求通常是 PD 提出的，都比较紧急，但并不总是特别重要；架构价值的工作内容，通常是开发同学提出的，都很重要但基本不是很紧急，短期内不做也死不了。我们开发同学，在低头敲代码之前，一定要把杂糅在一起的“重要且紧急”和“不重要但紧急”分开，把我们架构工作（“重要但不紧急”）插进去。

**其实所谓架构就是限制**，限制源码放在哪里、限制依赖、限制通信的方式，但这些限制比较上层。编程范式是最基础的限制，它限制我们的控制流和数据流：结构化编程限制了控制权的直接转移（限制了goto语句），面向对象编程限制了控制权的间接转移（限制了函数指针的使用），函数式编程限制了赋值

|编程范式||描述||
|---|---|---|---|
|结构化编程|限制控制权的直接转移|就是函数调用或者 goto 语句，代码在原来的流程里不继续执行了，转而去执行别的代码，并且你指明了执行什么代码。|限制goto语句|
|面向对象编程|限制控制权的间接转移|就是代码在原来的流程里不继续执行了，转而去执行别的代码，但具体执行了啥代码你也不知道，你只调了个函数指针或者接口。|限制函数指针|
|函数式编程|限制赋值|函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值||

没有结构化编程，程序就无法从一块块可证伪的逻辑搭建，没有面向对象编程，跨越组件边界会是一个非常麻烦而危险的过程，而函数式编程，让组件更加高效而稳定。没有编程范式，架构设计将无从谈起。

架构工作的基本方针

1. 尽可能长时间地保留尽可能多的可选项。
2. 低层次解耦方式能解决的，不要用高层次解耦方式。

组件拆分需要在两个维度进行：按层次拆分、按变更原因拆分。

## 从架构的过去看未来

[京东刘海锋：过去十年架构领域最重要的三个变化](https://mp.weixin.qq.com/s/_W9vUK8LY9RC1-QxfGFQSg)

架构领域经历了快速演进的十年。架构领域在整个互联网的技术栈是偏底层的，但过去十年架构领域的演进速度，一点都不亚于应用开发，甚至移动端开发的速度。比如容器，新型的数据库，新型的中间件，大规模集群的调度，以及系统跟算法的结合。比如

1. 容器
2. 数据库，数据库作为基础架构非常核心的组成部分，在过去的十年间里面有一个显著的特点是从大一统的一元的数据库逐渐走向多元，逐渐的走向为不同的应用场景而定制。以电商为例，一般来说会用 MySQL 以及 MySQL 的中间件，作为最关键的结构化存储，但同时会配上内存 KV Store 做加速、用检索型数据库做全文检索，用时间序列数据库做海量数据的监控采集和分析，等等。从 DB 底层核心技术来看，跨地域复制且强一致复制、计算与存储分离、**从以磁盘为中心到以内存为中心**，是三个非常显著的技术变迁。
3. 系统跟算法的结合越来越紧密，系统跟算法一起形成一家公司的技术的基石，系统相当于是骨架，而算法给骨架注入了灵魂。


软件架构，唯一不变的就是变化，但变化又分成了波动与趋势，所以对趋势的把握显得尤为重要。未来的两个预测

1. 架构智能化
2. 混合多云，接下来 5 到 10 年，很多大中型企业，他们重要的业务一定会横跨自己的数据中心和不同云服务商的数据中心。一定会有框架出现来屏蔽底层的这些差异与复杂性


## 《聊聊架构》 书评的笔记

[聊聊架构](http://www.infoq.com/cn/articles/talk-arch?utm_source=articles_about_talk-arch&utm_medium=link&utm_campaign=talk-arch)

### 多个范畴的生命周期

人一生的生命周期被各种不同的场景、任务、角色、身份切分成了各不相同的生命周期，其中有核心生命周期，有非核心生命周期，有些必须自己做，有些可以交给别人做。(读书、生活、谈恋爱)

在人类历史中，随着工作越来越复杂、工作任务越来越多，人类协作越来越精细，然后就产生了分工，**分工就是人类因为协作产生的生命周期的切分。**

明确了生命周期这个概念就会意识到，随着事物的发展，把它的一部分职能从其核心生命周期切分出去，构造出新的生命周期，能够帮助这一事物明确自身的核心生命周期、明确自己的职责和权力，**有更多时间用在自己擅长的事情上。**

### 代码、技术、业务和管理

**要分得清楚访问代码、业务代码、存储代码、胶水代码各自应在哪些层级**，它们应该是什么角色，而不是所有代码散乱的混在一起，看起来似乎按照经典的MVC分层，实际上业务代码却同时出现在controller/service/DAO，这样其实并没有明确的划分。

正确的做法应该是controller完成访问逻辑；DAO完成存储逻辑；service完成胶水逻辑，承上启下，利用DTO转换访问参数、执行业务逻辑、调用DAO映射存储模型、再利用DTO把业务处理结果转换为响应结果，业务逻辑在业务模型中实现。如果把业务逻辑跟业务数据在一起实现就是充血模型，进一步深化就是DDD模式。

如果把业务逻辑跟业务数据在一起实现就是充血模型，进一步深化就是DDD模式。只有这样才完成了明确的软件层次划分，每层各司其职、权责对等，否则就是大泥球。
明白了这一点，自然就能分得清楚业务的事务跟关系数据库的事务不是一回事，也就不会考虑完成业务上的事务要依赖关系数据库事务确保数据完整性。

完全可以把二者分开，利用更符合业务规律的做法去实现，甚至业务本身已经有成熟的方案确保数据完整性，而不再需要依赖关系数据库事务。在业务上对关系数据库事务ACID特性的依赖既然不再是必须，对拥有ACID特性的数据库依赖自然也就不再是必须，完全可以根据业务需要选择合适的存储方案。

业务模型和具体实现不再依赖于某些具体方案的技术特性，**实现了业务与技术的解耦**，也就更容易实现横向扩展。现在又发现横向扩展也是自然界的一个基本特性。无数基本粒子构成原子、无数原子构成一个具体的宏观物体，一个人不够用就增加更多人。**如果一个系统的规模在横向扩展上达到了瓶颈，不能再靠简单的增加数量获得提升的时候，一定是这个系统的组织架构存在某些不合理因素。**

说到这里自然就要说到业务和技术的关系。前面说到软件是现实世界的映射抽象，由虚拟人代替自然人去完成一些工作。要做好软件自然就要理解业务，对业务的理解越深刻就越有可能做出优秀的软件。

但是现实世界太复杂了，随着业务发展，软件规模会越来越大，复杂性越来越高，一个人难以胜任全部架构工作，于是就产生了架构师团队，架构师也有了更细致的分工。架构师的生命周期也相应发生了拆分，也就产生了**业务架构、应用架构、系统架构。**

架构师为了能够实现自己的架构思想，自然需要与职能对等的权力。所以架构师其实不是一个纯粹的技术职位，而是拥有管理职能的职位，而不同角色的架构师对技术的要求也不尽相同。

## 什么不是架构

[别让自己“墙”了自己](https://coolshell.cn/articles/20276.html)小型的项目用什么语言都行，爱用什么用什么。但是，真正的企业级架构就不一样了，其中并不仅仅只是RESTful API或RPC，还有各种配套设施和控制系统，比如：应用网关，服务发现、配置中心、健康检查、服务监控、服务治理（熔断、限流、幂等、重试、隔离、事务补偿）、Tracing监控、SOA/ESB、CQRS、EDA……这些东西在非Java的技术栈体系内，很难看到全貌，Java强大的生态环境，就是让你把注意力放到更高层次的架构和业务上来的。（千万不要觉得，整几个服务RPC一下，加个缓存，加个队列，就能叫架构，那只是系统集成罢了）