---

layout: post
title: 串一串一致性协议
category: 技术
tags: Distribute
keywords: 一致性协议

---

## 简介

* TOC
{:toc}

![](/public/upload/distribute/consistency.png)

## 什么是一致性

[关于分布式一致性的探究](http://www.hollischuang.com/archives/663)

从client和server的角度看

1. 从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。
2. 从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。

数据一致性

1. 在数据库系统中，通常指关联数据之间的逻辑关系是否正确和完整。
2. 在分布式系统中，指的是由于数据的复制，不同数据节点中的数据内容是否完整并且相同。

[分布式系统的CAP理论](http://www.hollischuang.com/archives/666): 一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。==> 当更新操作完成之后，任何多个（节点）后续进程或者线程的访问都会返回最新的更新过的值。

[被误用的“一致性”](http://blog.kongfy.com/2016/08/%E8%A2%AB%E8%AF%AF%E7%94%A8%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/) 一致性和算法的误区：我们常说的“一致性（Consistency）”在分布式系统中指的是副本（Replication）问题中对于同一个数据的多个副本，其对外表现的数据一致性，如线性一致性、因果一致性、最终一致性等，都是用来描述副本问题中的一致性的。

[分布式共识(Consensus)：Viewstamped Replication、Raft以及Paxos](http://blog.kongfy.com/2016/05/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86consensus%EF%BC%9Aviewstamped%E3%80%81raft%E5%8F%8Apaxos/)分布式共识问题，简单说，**就是在一个或多个进程提议了一个值应当是什么后，使系统中所有进程对这个值达成一致意见。** 

这样的协定问题在分布式系统中很常用，比如说选主（Leader election）问题中所有进程对Leader达成一致；互斥（Mutual exclusion）问题中对于哪个进程进入临界区达成一致；原子组播（Atomic broadcast）中进程对消息传递（delivery）顺序达成一致。对于这些问题有一些特定的算法，但是，**分布式共识问题试图探讨这些问题的一个更一般的形式，如果能够解决分布式共识问题，则以上的问题都可以得以解决。**

小结一下就是，一致性是一个结果，共识是一个算法，通常被用于达到一致性的结果。

在《区块链核心算法解析》中，则采用另一种描述方式：对于一组节点，如果所有节点均以相同的顺序执行一个（可能是无限的）命令序列c1,c2,c3...，则这组节点 实现了状态复制。

## 《区块链核心算法解析》

下面看下 《区块链核心算法解析》 中的思维线条

1. 两节点

	1. 客户端服务端，如何可靠通信？如何处理消息丢失问题
	2. 请求-确认，客户端一段时间收不到 确认则重发，为数据包标记序列号解决重发导致的重复包问题。这也是tcp 的套路

2. 单客户端-多服务端
3. 多客户端-多服务端

	1. 多服务端前 加一个 单一入口（串行化器）， 所以的客户端先发给 串行化器，再分发给服务端。即主从复制思路==> 串行化器单点问题
	2. 客户端先协调好，由一个客户端发命令

		1. 抽取独立的协调器。2pc/3pc 思路
		2. 客户端向所有的服务端申请锁，谁先申请到所有服务器的锁，谁说了算。缺点：客户端拿到锁后宕机了，尴尬！
		3. 票的概念，弱化形式的锁。paxos 套路（当然，具体细节更复杂）
		4. 广播多轮投票。随机共识算法，不准确描述：假设只对01取得共识，第一轮每个节点随机选定一个值，广播给其它所有节点，节点收到超过半数其它节点的值，如果恰好是同一个值，则节点改变自己本轮的“意见”，重新广播该值。

tips

1. paxos 无法保证确定性，即理论上存在一直无法达成一致、不停地投票的情况
2. paxos/随机共识算法等 假定 参与节点都按规则 运行的基础上
3. FLP 原理：不存在一个确定性算法 总是能解决共识问题。
4. 对于zk，我们常从一个客户端访问者的角度来观察。实际上，zookeeper 工作时，假设存在zk1、zk2和zk3集群，且client1 访问zk1 和client2 访问zk2， 是很容易存在同一时刻，cleint1和client2读写同一个配置的。

拜占庭节点：节点可能不按规则行事，甚至故意发送错误数据，多个拜占庭节点也可能串谋。

基于拜占庭节点达成共识

2. 拜占庭容错（BFT）算法，一系列算法的统称。网络中节点的数量和身份必须是提前确定好的
3. POW，间接共识，先选谁说了算，再达成共识。

两个算法对cap的侧重有所不同

## 从容错性强弱的角度来串一下一致性协议

本小节来自 [漫谈分布式系统、拜占庭将军问题与区块链](http://zhangtielei.com/posts/blog-consensus-byzantine-and-blockchain.html)

理解问题本身比理解问题的答案要重要的多。

||节点|目标|备注|
|---|---|---|---|
|传统分布式一致性问题|可信|在一个去中心化的网络中（考虑到网络延迟、宕机等情况），各个节点之间最终能够对于提议达成一致。
|拜占庭将军问题|不可信|所有忠诚的副官最终都接受相同的命令<br>如果主将是忠诚的，那么所有忠诚的副官都接受主将发出的命令|作者的推理是少有的比较易懂的了，建议看原文|

解决拜占庭问题，笔者感觉有两个点

1. 广播，一个将军的命令发给所有其它将军
2. 转发，A将收到的B 将军的信息也转发给其他所有将军

尽可能保证所有人都是“知情”的（假设不考虑网络问题，只考虑节点不可信问题），A 既知道B 给自己的意见，也知道B 给其他将军的意见 ==> 如果大家遵循相同的算法 ==> A 既知道自己的决策结果，也知道其他人的决策结果。

从信息论的角度来说，就是信息尽可能的冗余。熵是对不确定性的度量。从控制论的角度来看，应叫不确定性。当我们不知道某事物具体状态，却知道它有几种可能性时，显然，可能性种类愈多，不确定性愈大。不确定性愈大的事物，我们最后确定了、知道了，这就是说我们从中得到了愈多的信息，也就是信息量大。


从容错性角度来串一下一致性协议

||表现|算法|
|---|---|---|
|非拜占庭错误|节点故障或网络不通，只是收不到它的消息了，而不会收到来自它的错误消息。相反，只要收到了来自它的消息，那么消息本身是「忠实」的。|paxos|
|拜占庭错误|1. 叛徒的恶意行为，在不同的将军看来，叛徒可能发送完全不一致的作战提议。<br>2. 虽然并非恶意，出现故障（比如信道不稳定）导致的随机错误或消息损坏||
|拜占庭将军问题|叛徒发送前后不一致的作战提议，属于拜占庭错误；<br>而不发送任何消息，属于非拜占庭错误。|BTF|

BFT的算法应该可以解决任何错误下的分布式一致性问题，也包括Paxos所解决的问题。那为什么不统一使用BFT的算法来解决所有的分布式一致性问题呢？为什么还需要再费力气设计Paxos之类的一些算法呢？

1. 提供BFT这么强的错误容忍性，肯定需要付出很高的代价。比如需要消息的大量传递。对于运行环境的假设(assumption)
2. 具体到Lamport在论文中给出的解决「拜占庭将军问题」的算法，它还对运行环境的假设(assumption)有更强的要求。比如BTF 有一条： The absence of a message can be detected ==> 依赖某种超时机制 ==> 各节点时钟同步 ==> 同步模型。

区块链到底是什么？有人说是个无法篡改的超级账本，也有人说是个去中心化的交易系统，还有人说它是构建数字货币的底层工具。但是，从技术的角度来说，它首先是个解决了拜占庭将军问题的分布式网络，**在完全开放的环境中，实现了数据的一致性和安全性。而其它的属性，都附着于这一技术本质之上。**
